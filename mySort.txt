# Sorting Algorithm Description: Heap Sort

Heap Sort is a comparison-based sorting algorithm that arranges elements in a binary heap data structure. The input is separated into sorted and unsorted regions. The unsorted section is progressively shrunk by taking the largest piece out of it and putting it into the sorted region iteratively. Taking the provided array and creating a heap from it, then continuously taking the largest element out of the heap and placing it at the end of the array.

## Steps of the Algorithm:

1. Build a max heap from the input data.
2. The largest item is stored at the root. Replace it with the last item of the heap, followed by reducing the size of the heap.
3. Finally, heapify the root of the tree.
4. Repeat steps 2 and 3 until the heap size is 1.

## Java Implementation:

```java

    //HeapSort
    public static <T extends Comparable<? super T>> void heapSort(T[] arr) 
	{
        int n = arr.length;

        // Build heap
        for (int i = n / 2 - 1; i >= 0; i--) 
        {
            heapify(arr, n, i);
        }

        // One by one extract an element from heap
        for (int i = n - 1; i >= 0; i--) 
        {
            // Move current root to end
            T temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }

    // To heapify a subtree rooted with node i which is an index in arr[]. n is size of heap
    public static <T extends Comparable<? super T>> void heapify(T[] arr, int n, int i) 
    {
        int largest = i; // Initialize largest as root
        int left = 2 * i + 1; // left = 2*i + 1
        int right = 2 * i + 2; // right = 2*i + 2

        // If left child is larger than root
        if (left < n && arr[left].compareTo(arr[largest]) > 0) 
        {
            largest = left;
        }

        // If right child is larger than largest so far
        if (right < n && arr[right].compareTo(arr[largest]) > 0) 
        {
            largest = right;
        }

        // If largest is not root
        if (largest != i) 
        {
            T swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest);
        }
    }

    public static <T> void heapSort(T[] arr, Comparator<? super T> c) 
    {
        int n = arr.length;

        // Build heap
        for (int i = n / 2 - 1; i >= 0; i--) 
        {
            heapify(arr, n, i, c);
        }

        // One by one extract an element from heap
        for (int i = n - 1; i >= 0; i--) 
        {
            // Move current root to end
            T temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // call max heapify on the reduced heap
            heapify(arr, i, 0, c);
        }
    }

    // To heapify a subtree rooted with node i which is an index in arr[]. n is size of heap
    public static <T> void heapify(T[] arr, int n, int i, Comparator<? super T> c) 
    {
        int largest = i; // Initialize largest as root
        int left = 2 * i + 1; // left = 2*i + 1
        int right = 2 * i + 2; // right = 2*i + 2

        // If left child is larger than root
        if (left < n && c.compare(arr[left], arr[largest]) > 0) 
        {
            largest = left;
        }

        // If right child is larger than largest so far
        if (right < n && c.compare(arr[right], arr[largest]) > 0) 
        {
            largest = right;
        }

        // If largest is not root
        if (largest != i) 
        {
            T swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest, c);
        }
    }

Complexity Analysis:
•Time Complexity: O(n log n)
•Space Complexity: O(1)

In the complexity analysis, 'n' represents the number of elements in the input list. Heap Sort has a time complexity of O(n log n) for all cases. It has an in-place sorting nature with a moderate space complexity. Although it is not stable, it is efficient and widely used for various sorting applications.